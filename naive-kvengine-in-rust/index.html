

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="分享记录自己对于生活，学习与工作的见闻">
  <meta name="author" content="谭新宇">
  <meta name="keywords" content="">
  <meta name="description" content="版本 官网版本  前期准备Rust 学习  半小时学习 Rust Rustling 及 解答 Rust 语言圣经 及 习题 Rust 官方文档 Talent Plan Percolator Lab  过关过程Rust Project 1: The Rust toolbox本 project 过关代码可参考该 commit。 主要参照了 README 来完成本 project，具体过程比较 triv">
<meta property="og:type" content="article">
<meta property="og:title" content="Talent-Plan：用 Rust 实现简易 KV 引擎">
<meta property="og:url" content="https://tanxinyu.work/naive-kvengine-in-rust/index.html">
<meta property="og:site_name" content="谭新宇的博客">
<meta property="og:description" content="版本 官网版本  前期准备Rust 学习  半小时学习 Rust Rustling 及 解答 Rust 语言圣经 及 习题 Rust 官方文档 Talent Plan Percolator Lab  过关过程Rust Project 1: The Rust toolbox本 project 过关代码可参考该 commit。 主要参照了 README 来完成本 project，具体过程比较 triv">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnvQkj4GJmiTwJeV21SmMeFf.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnYwXTYAHx39aKM0Pljd8R7b.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnnTJ4rUCXtxN59nGmDPclRc.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnwOPKgrmNT5kp3zgO5UB2Tc.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcn1GHZz1EW2O6yQvws5Xz0Ah.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcn4BhJAA4AnwlfT6ksZkY7Ye.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnFEf4FsRUzUJXg3v9CORCQc.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnY6aDLMIS6gKAnE8vWIz1Gh.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnQyOZ7qGBDfLOSbKLQdpKXg.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnRZrLuatQsEySdLCweP9hJf.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnvogcxYCj6ePDFug2C3BYUg.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnjPcxYncr6MzPFaF5vITIFf.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnxthxhEe0zV8eIkzz9VYGOf.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnBf5TfEwrTv7qGI7BqvI1Lh.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnLi3nwF781srG69oyMI22Dh.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnBDm1Ma5cBgjhEakKRxtvMe.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnwANdnQiduaMqWuTfuqYqtf.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnfOG27BeMg3VNRx3DnIOySb.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnlWsXGHwpQAAaeTPofjL0Kd.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcn6NSpWGbC9UEkuyXIACdTJf.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnI8W6PH9TwZcCP0DC53yUub.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcn0ExuHszDnabB7fosTNAXXq.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnzfeeo29RWnUZNdMlRtSNKg.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnyJQWFUM6irMEkN22WYrW7c.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcncl0pVAsp6LqYau0QRjXAbc.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnGwjWKxNs7ZmeiWebu1lIoc.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnEArkStGv1C1Us4ew1SguPf.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnUw2Q2c0Bvoe3GjIFMHSE05.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnPj0lx11Jj3YB6h1REJY7Zf.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcn5rZYcmvMfYnXcat5LSeCos.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnG99bQVGuok6gTqhr05Kmkn.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnzQkpPos1qxbygU4KvMx7Xc.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcniO3GQy0JnxunBBQ3rH7ewg.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnkIOzLCHIFKMU89CnoFKRMc.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnH9edzFxF6Ey7CpeEELfj3d.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnjxp5q574LIf0hidMFs4E7d.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnq23CIUQa25i4rf4mFEbk5b.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcno48X01i1c9r5i1aeN1XUQh.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnZcbACyBVBV9JlUYqicx0we.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnkG00kSYp5ZcIaGm4TmiKpe.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnb0wlmKE1MrtOLIjPnjaiBd.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnkPconSZtYcnSV1O8K4loPk.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcn1WUh1RyixFp1UHgsRv44TV.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnsmyPz8LfrnLhML6AksCPDc.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnnVupdcBFwenEaIuUvFhWDh.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcn0lodECLFH3AjTT7CGOFGLg.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnJFwgaF5IXUqkq7iPFqorWd.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnzGfVRmcZ2kjZyKatOZ9uHb.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnPZjYAEANb7Z9O28Zm5rfIg.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnW993QBlpNeVJ1vocEYpCwe.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnaTmdxQINxNh6bgoVnbVpIh.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcn35QJnz7gVjIWmD7xrNrTCh.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnlZ4coU7mWqKybLfYC7pqgp.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnrM7s7ntdUZwS41euVNO2af.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnFBgZG4DdIytqlfeqrlmqxe.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnDij7HnjT3xTO0tBYJBmyEg.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnPQEGztT4pID88lJEVIpTKJ.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnRs4vfkVcwiEJoQLIJpHM7o.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcn9YBWH6fWTEqZroFFEmjfQd.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnj3SztibcQ3dVtk80AgHB5r.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnkFizeIlIHOkdtLdjiJXa1b.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnbIWT6ofbomscJjhYDsI3og.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcn2a3QFIu6KvawbPR6I8lb0d.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcncFWYwfER6WT9yFEYNoIIud.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnjhiY2nLL2YcXE6hcSQvbqg.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnUGMyrZgPdodAwns1WyUrwc.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnWKzKDZwn4IZ1VuXbeuicbg.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnrpuZM9Ienhb4A3R8PGHdAd.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcn4HmL8lEVkATOr4kedonK3f.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnqWEQYmfb87Ku1fwAHwutEg.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcn31tkUHW2shoqZ4XO6Mx3dR.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnAgA1VT5aM02gLqyi9YHJ6d.png">
<meta property="og:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnoPA82ks3t9N0DQJDlpDcIf.png">
<meta property="article:published_time" content="2022-08-28T14:48:16.000Z">
<meta property="article:modified_time" content="2022-08-28T15:01:40.099Z">
<meta property="article:author" content="谭新宇">
<meta property="article:tag" content="Rust">
<meta property="article:tag" content="存储引擎">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://tanxinyu.work/naive-kvengine-in-rust/boxcnvQkj4GJmiTwJeV21SmMeFf.png">
  
  <title>Talent-Plan：用 Rust 实现简易 KV 引擎 - 谭新宇的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/atelier.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"tanxinyu.work","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="谭新宇的博客" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>TXY</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/blog-background.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Talent-Plan：用 Rust 实现简易 KV 引擎">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-08-28 22:48" pubdate>
        2022年8月28日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.4k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      17 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Talent-Plan：用 Rust 实现简易 KV 引擎</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：3 个月前
                
              </p>
            
            <div class="markdown-body">
              <h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul>
<li><a href="https://github.com/pingcap/talent-plan/tree/master/courses/rust" target="_blank" rel="noopener">官网版本</a></li>
</ul>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>Rust 学习</p>
<ul>
<li><a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust" target="_blank" rel="noopener">半小时学习 Rust</a></li>
<li><a href="https://github.com/rust-lang/rustlings" target="_blank" rel="noopener">Rustling</a> 及 <a href="https://github.com/OneSizeFitsQuorum/rustlings/pull/1" target="_blank" rel="noopener">解答</a></li>
<li><a href="https://course.rs/about-book.html" target="_blank" rel="noopener">Rust 语言圣经</a> 及 <a href="https://zh.practice.rs/why-exercise.html" target="_blank" rel="noopener">习题</a></li>
<li><a href="https://kaisery.github.io/trpl-zh-cn/title-page.html" target="_blank" rel="noopener">Rust 官方文档</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/558415847" target="_blank" rel="noopener">Talent Plan Percolator Lab</a></li>
</ul>
<h2 id="过关过程"><a href="#过关过程" class="headerlink" title="过关过程"></a>过关过程</h2><h3 id="Rust-Project-1-The-Rust-toolbox"><a href="#Rust-Project-1-The-Rust-toolbox" class="headerlink" title="Rust Project 1: The Rust toolbox"></a>Rust Project 1: The Rust toolbox</h3><p>本 project 过关代码可参考该 <a href="https://github.com/OneSizeFitsQuorum/PracticalNetworkedApplications/commit/1a0ca3eb1af93c33a3bb9881dec782dbd623aa49" target="_blank" rel="noopener">commit</a>。</p>
<p>主要参照了 <a href="https://github.com/OneSizeFitsQuorum/talent-plan/blob/master/courses/rust/projects/project-1/README.md" target="_blank" rel="noopener">README</a> 来完成本 project，具体过程比较 trivial 不再细述。主要工作如下：</p>
<ul>
<li>搭建项目基本目录结构。</li>
<li>使用 <a href="https://docs.rs/clap/3.2.15/clap/" target="_blank" rel="noopener">clap</a> 来解析命令行参数，根据官方文档学习 crate 的具体使用方法。</li>
<li>使用 cargo.toml 中的若干参数，包括 dev-dependencies，条件编译等等。</li>
<li>完成基于内存 hashmap 的 KvStore 的增删改查接口。</li>
<li>增加包文档和函数文档并在文档中添加了文档测试</li>
<li>使用 cargo fmt 和 cargo clippy 来提升代码质量</li>
</ul>
<h3 id="Rust-Project-2-Log-structured-file-I-O"><a href="#Rust-Project-2-Log-structured-file-I-O" class="headerlink" title="Rust Project 2: Log-structured file I/O"></a>Rust Project 2: Log-structured file I/O</h3><p>本 project 过关代码可参考该 <a href="https://github.com/OneSizeFitsQuorum/PracticalNetworkedApplications/commit/fb097b172c46784ed7ebe24afdec0a8ab5d3d399" target="_blank" rel="noopener">commit</a>。</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>在阅读 failure crate 的 <a href="https://boats.gitlab.io/failure/" target="_blank" rel="noopener">文档</a> 之后，在本 project 中采用了第二种错误处理方式——自定义错误结构。通过定义 KVStoreError 结构体并使用 failure crate 提供的能力，可以很轻易地捕捉不同的错误并列举他们的表示，调用者也可以直接通过模式匹配的方式得到错误类型。</p>
<p>此外，通过为 io:Error 和 serde_json:Error 添加转换到 KVStoreError 的函数，在主逻辑中可以轻松的使用 ? 来向上传递错误，从而避免对 Result 类型的暴力 unwrap。</p>
<p>此外，还定义了 Result<T> 类型别名来统一本项目中所有的 Result 返回类型。</T></p>
<p><img src="/naive-kvengine-in-rust/boxcnvQkj4GJmiTwJeV21SmMeFf.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h4><p>对于包含一个 lib 包和一个 bin 包的 crate ，在 lib 包中，需要引用所有新增文件的文件名当做其模块名将其引入，此外还需要使用 pub use 语法来将 bin 包会用到的结构公开导出。</p>
<p>在 lib 包的任何文件里，都可以通过 crate:: 的方式来引入本 lib 库被公开导出的结构。</p>
<p>在 bin 包中，需要通过实际 crate 名：: 的方式来引入同名 lib 库被公开导出的结构。</p>
<p><img src="/naive-kvengine-in-rust/boxcnYwXTYAHx39aKM0Pljd8R7b.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnnTJ4rUCXtxN59nGmDPclRc.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnwOPKgrmNT5kp3zgO5UB2Tc.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcn1GHZz1EW2O6yQvws5Xz0Ah.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="结果捕捉"><a href="#结果捕捉" class="headerlink" title="结果捕捉"></a>结果捕捉</h4><p><img src="/naive-kvengine-in-rust/boxcn4BhJAA4AnwlfT6ksZkY7Ye.png" srcset="/img/loading.gif" lazyload alt></p>
<p>结果捕捉中的正常/异常处理需要满足以上题意的要求，因而在 main 函数中原样实现了以上需求如下。</p>
<p><img src="/naive-kvengine-in-rust/boxcnFEf4FsRUzUJXg3v9CORCQc.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>KvStore 结构体中各个变量含义如下：</p>
<ul>
<li>Index ：参照 bitcask 的模型，key 为 kv pair 的 key，value 并不存储对应的 value，而是存储该 value 在第 file_number 个文件的 offset 处，长度为 length。</li>
<li>current_readers：对于所有已经存在的文件，KvStore 都缓存了一个 BufReader 来便于 seek 到对应的 offset 去 read。实际上也可以没有该结构体每次需要 reader 时新建即可，但复用 reader 可以一定程度上减少资源的损耗。</li>
<li>current_writer：当前正在写入的 file，其每次写入只需要 append 即可，不需要 seek。新建一个 BufWriterWithPosition 结构体的原因是能够快速的获取当前写入的 offset，而不需要在通过 seek(SeekFrom::Current(0))（可能是系统调用） 的方式去获取。</li>
<li>current_file_number：当前最大的 file_number，每次 compaction 之后会新增 1。每个数据文件都会附带一个 file_number，file_number 越大的文件越新，该 version 能够保证恢复时的正确性。</li>
<li>dir_path：当前文件目录路径。</li>
<li>useless_size：当前无用的数据总和。当改值大于某一个阈值时，会触发一次 compaction。</li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcnY6aDLMIS6gKAnE8vWIz1Gh.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnQyOZ7qGBDfLOSbKLQdpKXg.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnRZrLuatQsEySdLCweP9hJf.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h4><p>使用 serde_json 将 set 命令序列化，接着再写入到 current_writer 中，然后在 index map 中维护该 key 的索引。注意如果某 key 之前已在 KvStore 中存在，则 insert 函数会返回该 key 的旧 value，此时需要维护 useless_size。最后判断如果 useless_size 超过某一个阈值，则进行一次 compact。</p>
<p>需要注意许多返回 Result<T, error> 的函数都可以通过 ? 而直接向上传递异常，这得益于 Rust 错误处理的良好抽象。</T,></p>
<p><img src="/naive-kvengine-in-rust/boxcnvogcxYCj6ePDFug2C3BYUg.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h4><p>首先在 index 中获取该 key 的索引，如果不存在则说明该 key 不存在直接返回即可，否则根据索引中的 file_number 在 current_readers 中拿到对应的 reader，seek 到对应的 offset 并读取长度为 length 的数据。如果存在则返回 value，否则说明遇到了异常，返回错误即可。</p>
<p><img src="/naive-kvengine-in-rust/boxcnjPcxYncr6MzPFaF5vITIFf.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="删除流程"><a href="#删除流程" class="headerlink" title="删除流程"></a>删除流程</h4><p>首先在 index 中获取该 key 的索引，如果不存在则说明该 key 不存在返回 ErrNotFound 错误即可，否则移除该索引，接着将 rm 命令序列化并写入到 current_writer 中以保证该 key 能够被确定性删除。注意对于能够找到对应 key 的 rm 命令，useless_size 不仅需要增加 rm 命令本身的长度，还需要增加之前 set 命令的长度，因为此时他们俩都已经可以被一起回收。 最后判断如果 useless_size 超过某一个阈值，则进行一次 compact。</p>
<p><img src="/naive-kvengine-in-rust/boxcnxthxhEe0zV8eIkzz9VYGOf.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="重启流程"><a href="#重启流程" class="headerlink" title="重启流程"></a>重启流程</h4><p>重启时首先初始化若干重要结构，最重要的是调用 recover 函数，该函数将遍历当前所有的文件，不仅将索引维护到 index 结构中，还会将 reader 维护到 current_readers 结构中，最后返回（当前最大的文件版本，当前所有文件的 useless_size)，接着利用 current_file_number 构建当前最大文件的 writer，需要注意由于 bitcask 模型是 append_only 的机制，所以在构建 writer 时需要使用 OpenOptions 来使得 append 属性为 true，这样重启后直接 append 即可。最后根据 use_less 判断是否需要 compact，最后返回即可。</p>
<p><img src="/naive-kvengine-in-rust/boxcnBf5TfEwrTv7qGI7BqvI1Lh.png" srcset="/img/loading.gif" lazyload alt></p>
<p>对于 Recover 函数，其需要读取数据目录中的所有文件，按照 file_number 从小到大的顺序去按序 apply 从而保证重启的正确性。</p>
<p>对于排序，不能直接对文件名排序，因为这样的排序是按照字母编码而不是按照 file_number 大小。因此需要先将所有的 file_number 解析出来再对数字进行排序，之后再利用这些数字索引文件名即可。需要注意这里利用了许多文件操作的链式调用，需要查很多文档。</p>
<p>在获取到排序好的 versions 之后，可以按序读取文件并将其维护到 index 和 current_readers 中去，注意在该过程中也要注意维护 useless_size。此外得益于 serde_json 的 from_reader().into_iter() 接口，可以按照迭代器的方式去读取 command，而不用关注何时到了末尾，应该读多少字节才可以解析出一个 command，这极大的简化了读取流程。</p>
<p><img src="/naive-kvengine-in-rust/boxcnLi3nwF781srG69oyMI22Dh.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnBDm1Ma5cBgjhEakKRxtvMe.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="合并流程"><a href="#合并流程" class="headerlink" title="合并流程"></a>合并流程</h4><p>当前的合并流程采用了暴力的全部合并策略，同时将合并放在了客户端可感知延迟的执行流程中。</p>
<p>当 useless_size 大于某个阈值时，会触发一次合并，此时会增加 file_number 并将 index 中所有的数据都写入到当前新建的文件中，同时更新内存中的索引。接着再删除老文件和对应的 reader，最后再新建一个文件承载之后的写入即可。</p>
<p>需要注意按照这个流程即使在合并的写文件过程中出现了重启也不会出现正确性问题。如果新文件的所有数据尚未 flush 成功，老文件并不会被删除，那么只要重启时会按照 file_number 从小到大的顺序进行重放，数据便不会丢失。</p>
<p><img src="/naive-kvengine-in-rust/boxcnwANdnQiduaMqWuTfuqYqtf.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnfOG27BeMg3VNRx3DnIOySb.png" srcset="/img/loading.gif" lazyload alt></p>
<h3 id="Rust-Project-3-Synchronous-client-server-networking"><a href="#Rust-Project-3-Synchronous-client-server-networking" class="headerlink" title="Rust Project 3: Synchronous client-server networking"></a>Rust Project 3: Synchronous client-server networking</h3><p>本 project 过关代码可参考该 <a href="https://github.com/OneSizeFitsQuorum/PracticalNetworkedApplications/commit/4bf43135e3f662bd7f3a40078d2e648f436ce632" target="_blank" rel="noopener">commit</a>。</p>
<h4 id="命令行解析"><a href="#命令行解析" class="headerlink" title="命令行解析"></a>命令行解析</h4><p>在本 project 中，命令行分为了客户端 kvs-client 和服务端 kvs-server 两处，因此需要分别进行解析。</p>
<p>对于 kvs-client，基本继承了 project2 的命令行解析工具，仅仅增加了 addr 的解析。此外也按照题意将正常输出打印在了 stdout 中，将错误输出打印在了 stderr 中并以非 0 值结束进程</p>
<p><img src="/naive-kvengine-in-rust/boxcnlWsXGHwpQAAaeTPofjL0Kd.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcn6NSpWGbC9UEkuyXIACdTJf.png" srcset="/img/loading.gif" lazyload alt></p>
<p>对于 kvs-server，则是按照题意重新写了参数解析器，并对于 engine 增加了只能 2 选 1 的约束。同时还利用 judge_engine 函数实现了引擎选择的判断：对于第一次启动，按照用户参数来启动对应的引擎，如未指定则使用 kvs；对于之后的启动，必须按照之前的引擎启动，若与用户参数冲突则报错。在参数无问题之后打出对应的关键配置既可。</p>
<p><img src="/naive-kvengine-in-rust/boxcnI8W6PH9TwZcCP0DC53yUub.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcn0ExuHszDnabB7fosTNAXXq.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnzfeeo29RWnUZNdMlRtSNKg.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnyJQWFUM6irMEkN22WYrW7c.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h4><p>在本 project 中对日志采用了集成轻量的 env_logger，参照 <a href="https://docs.rs/env_logger/0.9.0/env_logger/" target="_blank" rel="noopener">文档</a> 仅仅需要在进程启动时指定日志的最低级别即可。</p>
<p><img src="/naive-kvengine-in-rust/boxcncl0pVAsp6LqYau0QRjXAbc.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="命令传输"><a href="#命令传输" class="headerlink" title="命令传输"></a>命令传输</h4><p>本 project 直接使用了 tcp 级别的网络接口来传输命令，因而会有黏包的问题需要处理。</p>
<p>一般的解决方案是在流上发送每段数据前先写入长度，再写入真实的数据；这样在流上读数据时便可以先读长度，再读对应长度的数据后解除阻塞返回了。</p>
<p>这样的思路可以自己手写，也可以使用 serde 现成的 reader/writer 接口去实现。因而在客户端构建了一个 Client 结构体对 socket 进行了简单的包装。对于 request，使用了一个 BufWriter 的装饰器配以每次写完数据后的 flush 来降低系统调用的开销啊，其在内部已经能够做到先写入长度再写入数据。对于 response，则是参照重启恢复时的逻辑使用 Deserializer 接口构建 reader，并指定对应的反序列化类型以达到先读长度再读数据的问题。这样便可以利用 serde 帮助解决黏包问题。</p>
<p><img src="/naive-kvengine-in-rust/boxcnGwjWKxNs7ZmeiWebu1lIoc.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnEArkStGv1C1Us4ew1SguPf.png" srcset="/img/loading.gif" lazyload alt></p>
<p>对于服务端，获取 request 和发送 response 的流程和客户端类似。</p>
<p><img src="/naive-kvengine-in-rust/boxcnUw2Q2c0Bvoe3GjIFMHSE05.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="可扩展存储引擎"><a href="#可扩展存储引擎" class="headerlink" title="可扩展存储引擎"></a>可扩展存储引擎</h4><p>为了扩展存储引擎的多种实现，抽象出来了统一的 trait 接口 KvsEngine 以对上暴露 trait 的抽象而隐藏具体的实现细节。这样 kvs-server 在启动时便可以以 trait 的方式去访问 engine，而不需要在意其内部的实现细节。</p>
<p><img src="/naive-kvengine-in-rust/boxcnPj0lx11Jj3YB6h1REJY7Zf.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcn5rZYcmvMfYnXcat5LSeCos.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnG99bQVGuok6gTqhr05Kmkn.png" srcset="/img/loading.gif" lazyload alt></p>
<p>对于 KvStore，将其 set/get/remove 这三个方法抽象到了 KvsEngine 的实现中。</p>
<p><img src="/naive-kvengine-in-rust/boxcnzQkpPos1qxbygU4KvMx7Xc.png" srcset="/img/loading.gif" lazyload alt></p>
<p>对于 Sled，同样实现了 KvsEngine 的三个方法。需要注意其默认接口的语义和格式与 KvsEngine 不一致，因而需要增加对应的转换。</p>
<p>此外在 set 时注释掉对应的 flush 操作是由于增加上之后性能过于慢，无法在之后的 bench 阶段跑出结果。</p>
<p><img src="/naive-kvengine-in-rust/boxcniO3GQy0JnxunBBQ3rH7ewg.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>参照 <a href="https://github.com/OneSizeFitsQuorum/talent-plan/blob/master/courses/rust/projects/project-3/README.md" target="_blank" rel="noopener">Project3 文档</a> 中的介绍创建了 benches/benches 文件并参照 criterion 的 <a href="https://bheisler.github.io/criterion.rs/book/getting_started.html" target="_blank" rel="noopener">用户手册</a> 开始构建性能测试。</p>
<p><img src="/naive-kvengine-in-rust/boxcnkIOzLCHIFKMU89CnoFKRMc.png" srcset="/img/loading.gif" lazyload alt></p>
<p>对于性能测试中的三个问题：</p>
<ul>
<li>如何精准测量想要测量的时间，而不包括初始化和清理的时间：参照 <a href="https://bheisler.github.io/criterion.rs/book/user_guide/timing_loops.html" target="_blank" rel="noopener">criterion 计时迭代的文档</a> 选择了 iter_batched 接口来精准测量读写的时间，初始化的清理的时间并不会被包括在内。</li>
<li>尽管使用了 rand，如何使得每次迭代都确定性：这里通过在迭代之前利用 rand 的 <a href="https://rust-random.github.io/book/guide-seq.html" target="_blank" rel="noopener">choose_multiple</a> 函数创建好对应的写入数据，使得每次迭代的操作数都具有相同的集合。</li>
<li>在读 benchmark 中，如何保证选到的读集合是写集合的子集：这里采用了同样的方法，读集合是在写集合的集成上去随机选择，从而保证了读取必然能够读到。</li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcnH9edzFxF6Ey7CpeEELfj3d.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnjxp5q574LIf0hidMFs4E7d.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnq23CIUQa25i4rf4mFEbk5b.png" srcset="/img/loading.gif" lazyload alt></p>
<p>最终性能对比如下：尽管已经去掉了 sled 每次写入时的 flush 操作来减少其随机 IO，在单线程客户端的情况下，sled 引擎的写延时大概是自写 bitcask 引擎写延时的 20 倍；sled 引擎的读延时大概是自写 bitcask 引擎读延时的 800 倍。</p>
<p><img src="/naive-kvengine-in-rust/boxcno48X01i1c9r5i1aeN1XUQh.png" srcset="/img/loading.gif" lazyload alt></p>
<p>个人猜测产生如此悬殊对比的原因有可能是：</p>
<ul>
<li>Sled 专为多线程无锁设计，在单线程下无法体现其性能优势。</li>
<li>Sled 本质上是一种树状结构，其相比 hash 结构能够提供高效的范围查询，也能够在海量数据场景与磁盘结合起来提供稳定的读延时，因而在小数据量的单点查询场景相比 hash 结构并不占优势。</li>
<li>当前自写 bitcask 模型还没有引入并发处理的开销，而 sled 是并发安全的，如此对比并不公平。</li>
</ul>
<p>本来想用一些 profile 工具测量一下 sled 的火焰图查找一下原因，由于本人的电脑芯片是 M1Pro，许多 profile 工具类如 perf 安装还不是很方便。在参照 <a href="https://github.com/tikv/pprof-rs/blob/master/examples/criterion.rs" target="_blank" rel="noopener"> pprof-rs 的文档</a> 为 criterion 配置之后依然无法打出火焰图，猜测可能跟环境有关系，便没有进一步再研究了，之后有机会在 Linux 下再进行 profile 吧。</p>
<h3 id="Rust-Project-4-Concurrency-and-parallelism"><a href="#Rust-Project-4-Concurrency-and-parallelism" class="headerlink" title="Rust Project 4: Concurrency and parallelism"></a>Rust Project 4: Concurrency and parallelism</h3><p>本 project 过关代码可参考该 <a href="https://github.com/OneSizeFitsQuorum/PracticalNetworkedApplications/commit/3d31896e832cef31e78380794f768375fc1bfc70" target="_blank" rel="noopener">commit</a>。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>为了多线程需要抽象出线程池的概念，ThreadPool trait 定义如下：spawn 函数中的闭包 F 不仅需要满足 FnOnce() 的 bound 来满足近执行一次的语义，还要实现 Send + ‘static 的 bound 来实现线程安全的发送接收和足够长的生命周期。</p>
<p><img src="/naive-kvengine-in-rust/boxcnZcbACyBVBV9JlUYqicx0we.png" srcset="/img/loading.gif" lazyload alt></p>
<p>对于最简单的 NaiveThreadPool，仅仅需要在 spawn 的时候创建一个线程让其执行即可。</p>
<p><img src="/naive-kvengine-in-rust/boxcnkG00kSYp5ZcIaGm4TmiKpe.png" srcset="/img/loading.gif" lazyload alt></p>
<p>对于共享队列的 ThreadPool，参照 RustBook 中的 <a href="https://kaisery.github.io/trpl-zh-cn/ch20-02-multithreaded.html" target="_blank" rel="noopener">举例</a> 即可实现。大体思路是用 channel 做通信，让多个子线程竞争 job 去执行即可。需要注意以下三点：</p>
<ul>
<li>std 库自带的 channel 是 MPSC 类型，因而可以支持并发写但不支持并发读。因而要想实现多个子 thread 对 channel 的监听便需要用 Arc<Mutex<receiver>&gt; 来保证不存在并发读。此外也可以使用 crossbeam 的 <a href="https://github.com/crossbeam-rs/crossbeam/tree/master/crossbeam-channel" target="_blank" rel="noopener">mpsc channel</a> 来支持并发读，那样便直接 clone 即可。</Mutex<receiver></li>
<li>为了优雅停机，对于 Job 又包装了一层枚举和 Terminate 类型来支持子 thread 的优雅退出，此外还需要利用 Box 将闭包 F 放在堆上来支持线程安全的传递闭包。</li>
<li>由于单元测试中传入的闭包可能会 panic 但不想看到线程池中的线程减少，一种方案是检测到线程 panic 退出之后新增新的线程，另一种方式则是捕获可能得 panic。例如在 Java 中可以使用 try catch 捕捉一个 throwable 的错误，在 go 中可以 defer recover 一个 panic。在 rust 中类似的语法是 <a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html" target="_blank" rel="noopener">catch_unwind</a>，因而在执行真正的 job 闭包时，会使用 panic::catch_unwind(AssertUnwindSafe(job)) 的方式来确保该线程不会由于执行闭包而 panic。</li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcnb0wlmKE1MrtOLIjPnjaiBd.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnkPconSZtYcnSV1O8K4loPk.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcn1WUh1RyixFp1UHgsRv44TV.png" srcset="/img/loading.gif" lazyload alt></p>
<p>对于 RayonThreadPool，直接参考官网的样例初始化对应的 pool 并直接 spawn 给其即可。</p>
<p><img src="/naive-kvengine-in-rust/boxcnsmyPz8LfrnLhML6AksCPDc.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="多线程服务端"><a href="#多线程服务端" class="headerlink" title="多线程服务端"></a>多线程服务端</h4><p>在 KvServer 初始化时使用了一个线程池来管理不同 tcp 连接的读写，这样便可以使得并发的请求能够在多核 CPU 的服务端并行执行而不是并发执行。</p>
<p><img src="/naive-kvengine-in-rust/boxcnnVupdcBFwenEaIuUvFhWDh.png" srcset="/img/loading.gif" lazyload alt></p>
<p>注意在 KvServer 中还维护了一个 is_stop 的原子变量，该变量的作用是能够便于当前线程结束阻塞等待进而退出。之所以阻塞的原因是由于 tcplistener 的 incoming() 函数是阻塞的，因而一旦进入 serve 函数当前线程就阻塞了。在之后的性能测试中可能一个线程内想在启动 server 后开始迭代测试并最后关闭 server 并进行下一轮测试：此时如果是同步的写法就无法执行 serve 之后的函数，如果新建一个线程则无法在迭代测试之后通知该线程结束，因而加入了该原子变量之后不仅可以异步启动 server 从而在当前线程进行性能测试，又能够在当前线程的测试结束后以新建一个空 client 的方式关闭 server 以便下一轮测试不会再出现 address already in use 的错误。</p>
<p><img src="/naive-kvengine-in-rust/boxcn0lodECLFH3AjTT7CGOFGLg.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="KvsEngine-线程安全"><a href="#KvsEngine-线程安全" class="headerlink" title="KvsEngine  线程安全"></a>KvsEngine  线程安全</h4><p>KvsEngine trait 需要满足 Clone + Send + ‘static 的 bound，同时三个对应的接口也可以去掉 &amp;mut，因为变量的所有权和可变性已经转移到了智能指针中。</p>
<p><img src="/naive-kvengine-in-rust/boxcnJFwgaF5IXUqkq7iPFqorWd.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="SledKvsEngine-线程安全"><a href="#SledKvsEngine-线程安全" class="headerlink" title="SledKvsEngine 线程安全"></a>SledKvsEngine 线程安全</h4><p>Sled 引擎本身支持并发读写，因而直接对结构体 derive(Clone) 即可，其 set/get/remove 函数仅需挪去 self 的 &amp;mut 即可。</p>
<p><img src="/naive-kvengine-in-rust/boxcnzGfVRmcZ2kjZyKatOZ9uHb.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnPZjYAEANb7Z9O28Zm5rfIg.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnW993QBlpNeVJ1vocEYpCwe.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="KvStore-线程安全"><a href="#KvStore-线程安全" class="headerlink" title="KvStore 线程安全"></a>KvStore 线程安全</h4><p>KvStore 的线程安全则需要对之前的结构体做大量的改造，改造之后的 KvStore 不仅支持读写请求互相不阻塞，甚至对同一 FileReader 的读请求也可以不在应用层阻塞。</p>
<ul>
<li>对于 index 结构，将其转换为了并发安全的 DashMap 结构，同时又增加了 Arc 指针以便于在不同线程间共享。</li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcnaTmdxQINxNh6bgoVnbVpIh.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>对于 writer 结构，由于对同一文件的 append 操作从语义上来说便不支持并行，因而便通过 Arc<Mutex<Writer>&gt; 的方式将所有的线程串行起来</Mutex<Writer></li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcn35QJnz7gVjIWmD7xrNrTCh.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>对于 readers 结构，我参照了部分 project4 样例的源码设计进行了无锁实现。注意其内部的 readers 在 clone 时并不是拷贝指针，而是初始化一个全新的 map，因而当多线程读同一个文件时，会创建多个 reader，这些 reader 可以在应用层对同一个文件执行并发的 IO 读请求。使用 RefCell 包装的原因是由于接口并未提供可变引用，如果还想保留对 map 的更改权限就需要用到 RefCell 了。</li>
<li>最容易想到的一种读请求并发控制方案是在上层做一定的串行以使得每个文件最多同时只有一个读请求在执行，从而减少磁盘的随机 IO。但实际上这样的设计并不一定有效果，一方面由于在文件系统中一个 file 的所有 data block 不一定完全在连续的 block 上，因而仅仅限制对一个文件不能并发读而不限制对多个文件不能并发读不一定能够起到减少随机 IO 的效果，另一方面 linux VFS 下的 IO 调度层本来就已经会对 IO 请求通过电梯算法等方式来做一些乱序处理来减少随机 IO，如果完全在上层做了串行反而会丢失部分可优化吞吐的空间。因而如果系统还没到完全掌握磁盘快中数据的分布来减少随机 IO 的地步，可以先尽可能的将读请求并行起来让底层去串行，而不是在上层就做好串行。</li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcnlZ4coU7mWqKybLfYC7pqgp.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="写流程-1"><a href="#写流程-1" class="headerlink" title="写流程"></a>写流程</h4><p>由于 append 的写请求语义上就不能并行，因而当前 KvsEngine 的 set 请求被全部串行了起来</p>
<p><img src="/naive-kvengine-in-rust/boxcnrM7s7ntdUZwS41euVNO2af.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnFBgZG4DdIytqlfeqrlmqxe.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="删除流程-1"><a href="#删除流程-1" class="headerlink" title="删除流程"></a>删除流程</h4><p>由于删除也需要顺序 append，因而其语义与 set 类似不能并行，因而当前 KvsEngine 的 remove 请求也被全部串行了起来</p>
<p><img src="/naive-kvengine-in-rust/boxcnDij7HnjT3xTO0tBYJBmyEg.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="读流程-1"><a href="#读流程-1" class="headerlink" title="读流程"></a>读流程</h4><p>读流程语义理论上可以并行执行，因而首先在可并发读的 DashMap 中获取到索引，接着在当前线程内读取对应的 file_number 的 reader，如果当前线程不存在该 reader 则创建出对应的 reader 读取即可（使用了 entry API 来避免两次 hash）。</p>
<p><img src="/naive-kvengine-in-rust/boxcnPQEGztT4pID88lJEVIpTKJ.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnRs4vfkVcwiEJoQLIJpHM7o.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcn9YBWH6fWTEqZroFFEmjfQd.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="合并流程-1"><a href="#合并流程-1" class="headerlink" title="合并流程"></a>合并流程</h4><p>在实现无锁读之后，reader 的清理便不再能够串行起来了，因而需要一个多线程共享的原子变量来记录最新 compaction 之后的 file_number，小于这个 file_number 的文件和对应的 reader 便都可以删除了。</p>
<p>compact 流程会始终持有 writer 的写锁，因而此时并不存在并发安全问题，其在结束后会尝试删除掉过时的文件。不过该删除并不会影响其他读线程的 reader 句柄继续读去文件，这与 linux 文件系统的实现原理有关，直到任何线程都不存在指向该文件对应 inode 的句柄时便可以安全的释放该文件了。</p>
<p><img src="/naive-kvengine-in-rust/boxcnj3SztibcQ3dVtk80AgHB5r.png" srcset="/img/loading.gif" lazyload alt></p>
<p><img src="/naive-kvengine-in-rust/boxcnkFizeIlIHOkdtLdjiJXa1b.png" srcset="/img/loading.gif" lazyload alt></p>
<p>对于 reader，在 compaction 中其执行的索引尽管可能文件已经被删除了，但由于其持有句柄因而始终能够读到数据，在 compaction 之后其执行的索引一定是更新的文件，因而老的 reader 便不会再被用到，如果这些老 reader 一直不被释放，则可能导致合并过后的老文件始终无法在文件系统被释放，最终导致磁盘变满。因此在每次查询时都可以判断一下该原子变量并尝试删除本线程的老 reader，这样便可以既实现 lock-less 的 reader 又满足 compaction 消息的无锁感知和对应的资源清理了。</p>
<p><img src="/naive-kvengine-in-rust/boxcnbIWT6ofbomscJjhYDsI3og.png" srcset="/img/loading.gif" lazyload alt></p>
<h4 id="性能测试-1"><a href="#性能测试-1" class="headerlink" title="性能测试"></a>性能测试</h4><p>按照题意写出对应的六个 benchmark 即可，主要做了以下工作：</p>
<ul>
<li>使用 Once 接口来确保在多个函数中 logger 仅被初始化一次，从而避免报错。</li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcn2a3QFIu6KvawbPR6I8lb0d.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>使用了 <a href="https://bheisler.github.io/criterion.rs/book/user_guide/benchmarking_with_inputs.html" target="_blank" rel="noopener">bench_with_input</a> 接口来支持不同线程数的对比</li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcncFWYwfER6WT9yFEYNoIIud.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>使用了之前提到的方式来异步启动 server 并在一轮迭代结束后回收 server。</li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcnjhiY2nLL2YcXE6hcSQvbqg.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>使用了 waitGroup 来实现客户端线程和迭代线程的同步。</li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcnUGMyrZgPdodAwns1WyUrwc.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>减少 sample_size 来加快性能测试时间。</li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcnWKzKDZwn4IZ1VuXbeuicbg.png" srcset="/img/loading.gif" lazyload alt></p>
<p>最终的测试结果如下：</p>
<ul>
<li>write_queue_kvstore：随着线程数增大，延时先降再升，但变化幅度不大，尽管 read/write socket 可以并行起来了，但 set 还是必须得串行起来，与实现基本相符。</li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcnrpuZM9Ienhb4A3R8PGHdAd.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>read_queued_kvstore：随着线程数增大，延时先大幅度降低再大幅度升高，大幅度降低符合预期，因为不同的读请求现在可以串行起来，大幅度升高则不太符合预期，观察到了客户端建立连接 Timeout 的现象，不确定是否与本地的 Mac M1 Pro 环境有关。</li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcn4HmL8lEVkATOr4kedonK3f.png" srcset="/img/loading.gif" lazyload alt></p>
<p>其他测试：</p>
<ul>
<li>write_rayon_kvstore</li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcnqWEQYmfb87Ku1fwAHwutEg.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>read_rayon_kvstore</li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcn31tkUHW2shoqZ4XO6Mx3dR.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>write_rayon_sledkvengine</li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcnAgA1VT5aM02gLqyi9YHJ6d.png" srcset="/img/loading.gif" lazyload alt></p>
<ul>
<li>read_rayon_sledkvengine</li>
</ul>
<p><img src="/naive-kvengine-in-rust/boxcnoPA82ks3t9N0DQJDlpDcIf.png" srcset="/img/loading.gif" lazyload alt></p>
<p>测试总结：</p>
<ul>
<li>总体来看，不同的存储引擎，不同的线程池策略，随着服务端线程池的线程数增大，延时都能够在某点得到最小值，这说明并行能够在部分场景起到效果。</li>
<li>在 MacOS M1 Pro 的环境上测试性能不太稳定，还容易出现 timeout 的情况，因而便没有进行更详细分析，感觉要想真的对比出性能的差异，还是需要在 Linux 环境下配上稳定的 CPU，磁盘，网络的可观测性工具结合不同引擎和不同线程池的内部 metric 来分析原因。害，底层软件就是这么难测试。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本 Rust Lab，总共写了大约 2000+ 行的 Rust 代码。从 Cargo 包管理到 Rust 的所有权机制，然后到错误管理和若干标准库三方库的使用，再到线程池和并发引擎的设计以及异步 Runtime 的学习，虽然在性能测试和对比部分做的并不完善，但这些内容已经涵盖了开发大型 Rust 项目的方方面面。</p>
<p>下一步计划开始从 TiKV 的小 issue 入手，进一步深入学习 Rust。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Rust/">Rust</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/">存储引擎</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/tikv-source-code-reading-module/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">TiKV 源码阅读三部曲（一）重要模块</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/percolator-in-rust/">
                        <span class="hidden-mobile">Talent-Plan：用 Rust 实现 Percolator 算法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'OneSizeFitsQuorum/OneSizeFitsQuorum.github.io');
      s.setAttribute('issue-term', 'title');
      
      s.setAttribute('label', 'blog comments');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  








  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>
